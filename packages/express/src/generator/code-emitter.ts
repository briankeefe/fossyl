import type { RouteInfo, DatabaseAdapter } from '@fossyl/core';
import type { RouteNode } from "./route-tree-builder";
import type { AnalyzedMiddleware } from "./middleware-analyzer";
import type { ExpressAdapterOptions } from "../types";
import { emitAppSetup, emitResponseWrapper } from "../templates/app-setup";
import {
  emitAuthMiddlewareFactory,
  emitValidationMiddlewareFactory,
  emitQueryValidationMiddlewareFactory,
} from "../templates/middleware-factories";
import { emitErrorHandlers } from "../templates/error-handlers";
import { collectImports, formatImports, emitInlineErrorTypes } from "./imports-collector";
import { groupRoutesByPrefix } from "./route-tree-builder";

/**
 * Options for code emission including paths and adapter configuration.
 */
type EmitOptions = ExpressAdapterOptions & {
  outputPath: string;
  routesPath: string;
  databaseAdapter?: DatabaseAdapter;
};

/**
 * Generates the complete Express TypeScript application code.
 *
 * @param tree - Route tree (used for organizing routes)
 * @param routes - All routes to generate handlers for
 * @param analyzed - Analyzed middleware for hoisting decisions
 * @param options - Emission options
 * @returns Complete TypeScript code for the Express app
 */
export function emitExpressApp(
  tree: RouteNode,
  routes: RouteInfo[],
  analyzed: AnalyzedMiddleware,
  options: EmitOptions
): string {
  const wrapResponses = options.wrapResponses ?? true;

  // Collect and format imports
  const collected = collectImports(routes, options);
  const imports = formatImports(collected);

  // Generate app setup
  const setup = emitAppSetup(options);

  // Generate inline error types
  const errorTypes = emitInlineErrorTypes();

  // Generate response wrapper
  const responseWrapper = emitResponseWrapper(wrapResponses);

  // Generate middleware factories
  const middlewareFactories = emitMiddlewareFactories(routes);

  // Generate routers and routes
  const routers = emitRouters(routes, analyzed, {
    wrapResponses,
    databaseAdapter: options.databaseAdapter,
  });

  // Generate error handlers
  const errorHandlers = emitErrorHandlers();

  return `
// ============================================
// Generated by fossyl with @fossyl/express
// Do not edit - regenerate with: npx fossyl build
// ============================================

${imports}

${errorTypes}

${setup}

${responseWrapper}

${middlewareFactories}

${routers}

${errorHandlers}

export { app };
`.trim();
}

/**
 * Emits middleware factory functions based on what's needed.
 */
function emitMiddlewareFactories(routes: RouteInfo[]): string {
  const factories: string[] = [];

  // Check if we need auth middleware
  const needsAuth = routes.some(
    (r) => "authenticator" in r.route && r.route.authenticator
  );
  if (needsAuth) {
    factories.push(emitAuthMiddlewareFactory());
  }

  // Check if we need body validation middleware
  const needsBodyValidation = routes.some(
    (r) => "validator" in r.route && r.route.validator
  );
  if (needsBodyValidation) {
    factories.push(emitValidationMiddlewareFactory());
  }

  // Check if we need query validation middleware
  const needsQueryValidation = routes.some((r) => {
    const route = r.route as { queryValidator?: unknown };
    return "queryValidator" in route && route.queryValidator;
  });
  if (needsQueryValidation) {
    factories.push(emitQueryValidationMiddlewareFactory());
  }

  return factories.join("\n\n");
}

/**
 * Emits all routers and their routes.
 */
function emitRouters(
  routes: RouteInfo[],
  analyzed: AnalyzedMiddleware,
  options: { wrapResponses: boolean; databaseAdapter?: DatabaseAdapter }
): string {
  // Group routes by common prefix
  const groups = groupRoutesByPrefix(routes);
  const routerCode: string[] = [];

  for (const [prefix, groupRoutes] of groups) {
    routerCode.push(
      emitRouterGroup(prefix, groupRoutes, analyzed, options)
    );
  }

  return routerCode.join("\n\n");
}

/**
 * Emits a router group with its routes.
 */
function emitRouterGroup(
  prefix: string,
  routes: RouteInfo[],
  analyzed: AnalyzedMiddleware,
  options: { wrapResponses: boolean; databaseAdapter?: DatabaseAdapter }
): string {
  const routerName = prefixToRouterName(prefix);

  // Sort routes: static before dynamic
  const sortedRoutes = sortRoutesBySpecificity(routes);

  const routeHandlers = sortedRoutes
    .map((routeInfo) => {
      const relativePath = getRouteRelativePath(routeInfo.route.path, prefix);
      return emitSingleRoute(
        routeInfo,
        relativePath,
        routerName,
        analyzed,
        options
      );
    })
    .join("\n\n");

  return `
// Routes: ${prefix}
const ${routerName} = express.Router();

${routeHandlers}

app.use('${prefix}', ${routerName});
`.trim();
}

/**
 * Converts a URL prefix to a valid router variable name.
 */
function prefixToRouterName(prefix: string): string {
  const parts = prefix.split("/").filter(Boolean);
  if (parts.length === 0) return "rootRouter";

  return (
    parts
      .map((p) => (p.startsWith(":") ? p.slice(1) : p))
      .map((p, i) =>
        i === 0 ? p.toLowerCase() : p.charAt(0).toUpperCase() + p.slice(1)
      )
      .join("") + "Router"
  );
}

/**
 * Gets the route path relative to the router prefix.
 */
function getRouteRelativePath(fullPath: string, prefix: string): string {
  if (fullPath === prefix) return "/";
  if (fullPath.startsWith(prefix)) {
    const relative = fullPath.slice(prefix.length);
    return relative.startsWith("/") ? relative : "/" + relative;
  }
  return fullPath;
}

/**
 * Sorts routes so static paths come before dynamic params.
 */
function sortRoutesBySpecificity(routes: RouteInfo[]): RouteInfo[] {
  return [...routes].sort((a, b) => {
    const aSegments = a.route.path.split("/");
    const bSegments = b.route.path.split("/");

    // Compare segment by segment
    const minLen = Math.min(aSegments.length, bSegments.length);
    for (let i = 0; i < minLen; i++) {
      const aIsParam = aSegments[i].startsWith(":");
      const bIsParam = bSegments[i].startsWith(":");

      if (!aIsParam && bIsParam) return -1;
      if (aIsParam && !bIsParam) return 1;
    }

    // Shorter paths first if all else equal
    return aSegments.length - bSegments.length;
  });
}

/**
 * Emits a single route within a router.
 */
function emitSingleRoute(
  routeInfo: RouteInfo,
  relativePath: string,
  routerName: string,
  analyzed: AnalyzedMiddleware,
  options: { wrapResponses: boolean; databaseAdapter?: DatabaseAdapter }
): string {
  const route = routeInfo.route;
  const method = route.method.toLowerCase();
  const exportName = routeInfo.exportName;

  // Build middleware chain
  const middlewares = buildMiddlewareChain(routeInfo, analyzed);

  // Build the handler invocation
  const handlerInvocation = buildRouteHandlerInvocation(routeInfo, options);

  const middlewareStr =
    middlewares.length > 0 ? `\n  ${middlewares.join(",\n  ")},` : "";

  return `${routerName}.${method}('${relativePath}',${middlewareStr}
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      ${handlerInvocation}
    } catch (error) {
      next(error);
    }
  }
);`;
}

/**
 * Builds the middleware chain for a route.
 */
function buildMiddlewareChain(
  routeInfo: RouteInfo,
  analyzed: AnalyzedMiddleware
): string[] {
  const middlewares: string[] = [];
  const route = routeInfo.route;

  // Add authentication middleware if present and not hoisted
  if ("authenticator" in route && route.authenticator) {
    const authName = route.authenticator.name || "authenticator";
    const isHoisted = analyzed.authenticators.has(authName);
    if (!isHoisted) {
      middlewares.push(`createAuthMiddleware(${exportName(routeInfo)}.authenticator)`);
    }
  }

  // Add body validation middleware for routes with validators
  if ("validator" in route && route.validator) {
    middlewares.push(`createValidationMiddleware(${exportName(routeInfo)}.validator)`);
  }

  // Add query validation middleware if present
  const routeWithQuery = route as { queryValidator?: { name?: string } };
  if ("queryValidator" in routeWithQuery && routeWithQuery.queryValidator) {
    middlewares.push(`createQueryValidationMiddleware(${exportName(routeInfo)}.queryValidator)`);
  }

  return middlewares;
}

/**
 * Gets the export name for a route.
 */
function exportName(routeInfo: RouteInfo): string {
  return routeInfo.exportName;
}

/**
 * Builds the handler invocation code for a route.
 */
function buildRouteHandlerInvocation(
  routeInfo: RouteInfo,
  options: { wrapResponses: boolean; databaseAdapter?: DatabaseAdapter }
): string {
  const route = routeInfo.route;
  const routeExportName = routeInfo.exportName;

  // Build params object
  const routeWithQuery = route as { queryValidator?: unknown };
  const hasQuery = "queryValidator" in routeWithQuery && routeWithQuery.queryValidator;
  const paramsObj = hasQuery
    ? "{ url: req.params, query: (req as Request & { fossylQuery: unknown }).fossylQuery }"
    : "{ url: req.params }";

  const responseWrapper = options.wrapResponses
    ? "wrapResponse(result)"
    : "result";

  let handlerCall: string;

  switch (route.type) {
    case "open":
      handlerCall = `const result = await ${routeExportName}.handler(${paramsObj});`;
      break;

    case "authenticated":
      handlerCall = `const auth = req.fossylAuth;
      const result = await ${routeExportName}.handler(${paramsObj}, auth);`;
      break;

    case "validated":
      handlerCall = `const body = req.fossylBody;
      const result = await ${routeExportName}.handler(${paramsObj}, body);`;
      break;

    case "full":
      handlerCall = `const auth = req.fossylAuth;
      const body = req.fossylBody;
      const result = await ${routeExportName}.handler(${paramsObj}, auth, body);`;
      break;
  }

  // Wrap with database transaction if configured
  if (options.databaseAdapter) {
    handlerCall = options.databaseAdapter.emitWrapper(handlerCall, true);
  }

  return `${handlerCall}
      res.json(${responseWrapper});`;
}
